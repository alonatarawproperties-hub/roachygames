REPLIT AGENT TASK: Fix GPS “jumping/teleport” while user is stationary in Roachy Hunt (Expo Location). Do NOT touch any spawn logic, quest logic, UI layout, TanStack queries, or server routes. Only modify TWO files:
1) client/screens/HuntScreen.tsx
2) client/context/HuntContext.tsx

GOAL:
- When user is sitting still, the player dot must NOT jump around.
- When user walks normally, location updates must still feel responsive.
- Reject outlier readings (wifi triangulation / drift) and unrealistic teleports.
- Reduce server spam POST /api/hunt/location from micro-jitter.

========================================================
1) FILE: client/screens/HuntScreen.tsx
========================================================

A) Add these refs + helper function INSIDE the HuntScreen component (near other refs like bestAccuracyRef, locationSubscriptionRef, isMountedRef):

const lastAcceptedRef = useRef<{
  lat: number;
  lng: number;
  ts: number; // ms
  accuracy: number;
} | null>(null);

function haversineMeters(lat1: number, lon1: number, lat2: number, lon2: number) {
  const R = 6371000;
  const toRad = (v: number) => (v * Math.PI) / 180;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) ** 2 +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
  return 2 * R * Math.asin(Math.sqrt(a));
}

B) In startLocationTracking(), find the Location.watchPositionAsync call and adjust the options to be less twitchy:
- Change timeInterval from 1000 to 2000
- Change distanceInterval from 2 to 5

It should be:

locationSubscriptionRef.current = await Location.watchPositionAsync(
  {
    accuracy: Location.Accuracy.BestForNavigation,
    timeInterval: 2000,
    distanceInterval: 5,
  },
  (newLocation) => { ... }
);

C) Replace ONLY the INSIDE of the watchPositionAsync callback with the following logic (keep the surrounding watchPositionAsync structure intact). This is the core anti-teleport filter:

(newLocation) => {
  if (!isMountedRef.current) return;

  const coords = newLocation.coords;
  const accuracy = coords.accuracy ?? 999; // meters
  const ts = newLocation.timestamp ?? Date.now();

  setGpsAccuracy(accuracy);

  const lat = coords.latitude;
  const lng = coords.longitude;

  // Always accept the very first fix
  if (!lastAcceptedRef.current) {
    lastAcceptedRef.current = { lat, lng, ts, accuracy };
    hasInitialLocation = true;

    const heading = coords.heading;
    updateLocation(
      lat,
      lng,
      heading !== null && heading >= 0 ? heading : undefined
    );
    return;
  }

  const prev = lastAcceptedRef.current;
  const dtSec = Math.max(0.5, (ts - prev.ts) / 1000);
  const distM = haversineMeters(prev.lat, prev.lng, lat, lng);
  const speedMps = distM / dtSec;

  // Tunables (by-foot game)
  const MAX_BAD_ACCURACY = 65;     // ignore readings worse than this
  const STATIONARY_DIST = 6;       // within 6m treated as still (jitter)
  const MIN_MOVE_TO_UPDATE = 8;    // must move >= 8m to update
  const MAX_SPEED_MPS = 8;         // blocks teleports (8 m/s ~ 28.8kph)
  const MAX_JUMP_BASE = 35;        // allow slightly more if dt is large
  const MAX_JUMP = Math.max(MAX_JUMP_BASE, MAX_SPEED_MPS * dtSec);

  // 1) Reject poor accuracy readings (prevents WiFi bounce)
  if (accuracy > MAX_BAD_ACCURACY) return;

  // 2) Reject teleports (too far for the time elapsed)
  if (distM > MAX_JUMP) return;

  // 3) If stationary, ignore jitter unless accuracy improves significantly
  const accuracyImprovedALot = accuracy + 10 < prev.accuracy; // 10m better
  if (distM < STATIONARY_DIST && !accuracyImprovedALot) return;

  // 4) Only update when movement is meaningful OR accuracy improved a lot
  if (distM < MIN_MOVE_TO_UPDATE && !accuracyImprovedALot) return;

  // Accept this fix
  lastAcceptedRef.current = { lat, lng, ts, accuracy };
  hasInitialLocation = true;

  if (accuracy < bestAccuracyRef.current) {
    bestAccuracyRef.current = accuracy;
  }

  const heading = coords.heading;
  updateLocation(
    lat,
    lng,
    heading !== null && heading >= 0 ? heading : undefined
  );
};

D) IMPORTANT: Do not change the rest of startLocationTracking() logic, permission checks, or any other hooks.

========================================================
2) FILE: client/context/HuntContext.tsx
========================================================

Throttle POST /api/hunt/location so server doesn’t get spammed by tiny jitter.
Keep setPlayerLocation immediate, but only POST when:
- moved >= 10 meters OR
- 10 seconds elapsed since last POST

Replace the existing updateLocation useCallback with this full block:

const updateLocation = useCallback(async (latitude: number, longitude: number, heading?: number) => {
  setPlayerLocation({ latitude, longitude, heading });

  const now = Date.now();
  const prev = (globalThis as any).__lastHuntPost as { lat: number; lng: number; ts: number } | null;

  const haversineMeters = (lat1: number, lon1: number, lat2: number, lon2: number) => {
    const R = 6371000;
    const toRad = (v: number) => (v * Math.PI) / 180;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);
    const a =
      Math.sin(dLat / 2) ** 2 +
      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
    return 2 * R * Math.asin(Math.sqrt(a));
  };

  const moved = prev ? haversineMeters(prev.lat, prev.lng, latitude, longitude) : 999;
  const elapsed = prev ? (now - prev.ts) : 999999;

  if (prev && moved < 10 && elapsed < 10000) {
    return; // skip spam POST
  }

  (globalThis as any).__lastHuntPost = { lat: latitude, lng: longitude, ts: now };

  try {
    await apiRequest("POST", "/api/hunt/location", {
      walletAddress,
      latitude,
      longitude,
    });
  } catch (error) {
    console.error("Failed to update location:", error);
  }
}, [walletAddress]);

========================================================
3) REQUIRED TESTS (DO THESE AFTER CHANGES)
========================================================
1) Sit still 2-3 minutes: dot should NOT jump/teleport.
2) Walk 20-50m: dot should update smoothly every few steps.
3) If accuracy becomes poor: updates should pause instead of teleporting.

DO NOT modify any other files. DO NOT refactor unrelated code. Implement exactly.